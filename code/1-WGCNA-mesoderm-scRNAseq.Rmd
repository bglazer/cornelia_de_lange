---
title: "WGCNA of Mesoderm Data"
output:
  html_notebook:
    self_contained: yes
    smart: no
    toc: yes
    toc_depth: 4
---

# Setup
First, we load all the necessary libraries and functions (not shown in notebook).
```{r, setup, include=FALSE}
knitr::opts_knit$set(root.dir ="/Users/smgroves/Documents/GitHub/mesoderm_booleabayes_project/")
```

```{r install, include=FALSE}

# needed from BioConductor: impute
# install.packages("WGCNA", "NMF", "Signac")
##########################################
#### 1. Setup: load packages and functions
##########################################
  
library(WGCNA)
options(stringsAsFactors = FALSE)
allowWGCNAThreads()
library(gplots)
library(RColorBrewer)
library(NMF)


choose_directory <- function(caption = 'Choose directory for output') 
{
  if (exists('utils::choose.dir')) {
    choose.dir(caption = caption) 
  } else {
    tcltk::tk_choose.dir(caption = caption)
  }
}

##########################################
#### 2. Define global parameters
##########################################

SAVEFILES <- TRUE
networkType <- 'signed'
corFnc <- 'cor'
wd <- choose_directory()
if(!dir.exists(file.path(wd,networkType,corFnc))) dir.create(file.path(wd,networkType,corFnc), recursive = TRUE)
wd <- file.path(wd,networkType,corFnc)

```



# Load data

Data file previously generated by Stephen. Log normalized and low quality cells filtered out. 

```{r gene-expression}
gev <- read.csv('data/log1p-normalized-counts-mesoderm-wildtype.csv', row.names=1)

nSamples <- ncol(gev)
nGenes <- nrow(gev)
message(paste(nGenes,'genes and',nSamples,'cell lines will be used in the analysis'))


message(paste('A',networkType,'network will be constructed.'))

# for an unsigned network, it is probably best (needed?) for the data to be median centered
# to identify directionality of gene expression changes
if(networkType == 'unsigned') 
{
    gev <- sweep(gev,1,apply(gev,1,median,na.rm=T))
    message('Since an unsigned network will be constructed, the data have been median-centered across samples')
}
gev <- t(gev)
```
# Load cell line phenotype info
Load previously obtained cell line clustering (phenotype) information.
```{r phenotypes}
phenotypes <- read.csv('data/metadata-mesoderm-wildtype.csv',as.is=TRUE,row.names=1)
```

# Network construction
The next steps (5--9) are the meat of the analysis (network construction and validation). We will be considering a "signed" network, which means only positive correlations are captured (negative correlations are given a score of 0). An unsigned network would include both positively and negatively correlated genes in module. 

## Choose power value to maximize scale-free structure
This step determines the exponent to apply to the correlation coefficients (power). This is based on a soft thresholding approach to identify the minimum value that produces a scale-free network. This is the weighting of the network. 

```{r power-value}
powers <- c(c(1:10), seq(from=12, to=20, by=2))
sft <- pickSoftThreshold(gev, powerVector=powers, verbose=5, networkType=networkType)


softPower <- sft$powerEstimate
message(paste('A power value of',softPower,'was chosen.'))
```


## Compute adjacency and TOM
The adjacency matrix is the correlation or distance between genes calculated from the expression data. The default correlation function (`corFnc`) is `cor` (Pearson) which assumes normally distributed gene expression across samples. An alternative function is `bicor` that is more robust to outliers.


```{r Compute adjacency and TOM}
start.time <- Sys.time()
adjacency <- adjacency(gev, power=softPower, type=networkType
                     , corFnc=corFnc, 
                     #corOptions = "use = 'p', maxPOutliers = 0.1"
    )

# NOTE: if using non-filtered data, this steps can take an EXTREMELY long time
TOM <- TOMsimilarity(adjacency)
dissTOM <- 1-TOM
plotTOM <- dissTOM^softPower
diag(plotTOM) <- NA
```

## Cluster genes based on distance
This step relies on the `fastcluster` implementation of the `hclust` function, which is embedded in the `WGCNA` package. The module boundaries are determined using the function `cutreeDynamic` and assigned colors in order using the function `labels2colors`. This function is simply selecting `standardColors()` by number associated with each module. The functions `plotDendroAndColors` and `TOMplot` each plot the dendrograms of the gene correlation, the resultant modules and colors associated with each module.


```{r Cluster genes}
hierTOM <- hclust(as.dist(dissTOM), method="average") 
geneTree <- hierTOM

minModuleSize <- 100 # Probably depends on total number of genes - in general want large-ish modules
dynamicMods <- cutreeDynamic(   dendro=geneTree, distM = dissTOM, deepSplit=2, 
                                pamRespectsDendro=FALSE,
                                minClusterSize=minModuleSize)
dynamicColors <- labels2colors(dynamicMods)
 
if(SAVEFILES) pdf(file=file.path(wd,"WGCNA_dendrogram.pdf"))
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
     dendroLabels=FALSE, hang=0.03, addGuide=TRUE, guideHang=0.05, 
     main="Gene dendrogram and module colors")
if(SAVEFILES) dev.off()

table(dynamicColors)

if(SAVEFILES) save(geneTree, dynamicColors, file=file.path(wd,"trees_and_colors.RData"))
if(SAVEFILES) pdf(file.path(wd,"TOMplot.pdf"))
TOMplot(plotTOM, hierTOM, dynamicColors, main="Topological Overlap Matrix", na.rm=FALSE) 
if(SAVEFILES) {
    message("saving Topological Overlap Matrix plot")
    dev.off()
}

message(paste("Calculating adjacency and TOM took",round(difftime(Sys.time(),start.time,units="mins"),3),"minutes"))

```


## Test module robustness
This step helps to ensure the genes comprising each cluster have not simply been assigned to a cluster by random chance and provides a quantitative metric of membership (kME). The function `sampledBlockwiseModules` provides a simple means of accomplishing this by repeating the analysis multiple times including different samples of genes and cell lines.

```{r Test module robustness}

# Check that there are no strong outliers by calculating the standardized inter-sample connectivity Z.k.
start.time <- Sys.time()
if(corFnc=='cor'){
  corType = 'pearson'
}else{
  corType = 'bicor'
}
  
mods0 <- sampledBlockwiseModules(
      datExpr = gev,
      nRuns = 50,
      replace = TRUE,
      minModuleSize = 50,
      nPowerCheckSamples = 100,
      maxBlockSize = 30000,
     corType = corType,
      power = softPower,
      networkType = networkType,
      deepSplit = 1.5,
      reassignThreshold = 0,
      numericLabels = TRUE,
      checkMissingData = TRUE,
      pamRespectsDendro = FALSE,
      verbose = 0
)
# Save the resampled modules
if(SAVEFILES) save(mods0, file = file.path(wd,"Resampledmods.RData"))
message(paste("Module robustness took",round(difftime(Sys.time(),start.time,units="mins"),3),"minutes"))

```

## Validate module stability
Direct contact with Peter Langfelder (WGCNA developer) resulted in the following suggestions to obtain the most stable set of genes per module.

* Store the module colors of the 50 resamplings in a matrix (number of genes)x50
* Rerun blockwiseModules and supply the matrix in argument stabilityLabels.
* You can also choose a value for argument minStabilityDissim (I usually use values between 0.4 and 0.5.)
* Module identification then uses the resampled labels to merge modules which are not distinct enough in a majority of the resampled module labels.

These steps should result in fewer and larger modules that are more stable.

```{r Module stabilization}
# load(file.path(wd,"Resampledmods.RData"))

nRuns <- 49
# Define a matrix of labels for the original and all resampling runs
mylabels <- matrix(0, nGenes, nRuns + 1)
mylabels[, 1] <- mods0[[1]]$mods$colors

# Relabel modules in each of the resampling runs so that full and resampled modules with best overlaps have the same labels. This is achieved by the function matchLabels.
for (r in 2:(nRuns+1))
    mylabels[, r] <- matchLabels(mods0[[r]]$mods$colors, mylabels[, 1])

#mods1 = 150 cutoff
#mods2 = 110 cutoff
mods1 <- blockwiseModules(
    stabilityLabels = mylabels,
    minStabilityDissim = .45,
    deepSplit = 1.5,
    datExpr = gev,
    maxBlockSize = 30000,
    power = softPower,
    networkType = networkType,
    numericLabels = TRUE,
    checkMissingData = TRUE,
    pamRespectsDendro = FALSE,
    verbose = 5,
    saveTOMs = TRUE,
    saveTOMFileBase = file.path(wd,"stabilityModsTOM-blockwise"),
    minModuleSize = 110
)
```


# Save final outputs
The final outputs include:

* Stable modules (lists of genes in each module)
* Module eigengenes
* Module membership values (kME) for each gene.
* Clustered cell lines based on module eigengenes

To save the files, `saveFiles` should be set to `TRUE`.
```{r Save output}
saveFiles=TRUE

# # Now extract all module eigengenes and gene lists
MEs <-  mods1$MEs
rownames(MEs) <- rownames(gev)
clusters <- hclust(dist(MEs))
# 
# sizeGrWindow(7,6)
# par(mfrow = c(1,1))
# plot(clusters, main = "Clustering of cell lines by eigengenes",
#      xlab = "", sub = "", cex = 0.5)
# 
MEs <- MEs[clusters$order,]
kMEs <- signedKME(gev, MEs)
kIMs <- intramodularConnectivity.fromExpr(gev, mods1$colors,
              networkType = networkType)
rownames(kIMs) <- rownames(kMEs)

if(saveFiles)
{
    write.csv(data.frame(networkType=networkType, power=softPower, nGenes=nGenes, nSamples=nSamples),
        file=file.path(wd,"WGCNA_parameters.csv"),row.names=FALSE)
    save(mods1, file = file.path(wd,"Stable_modules_MC.RData"))
    save(mylabels, file = file.path(wd,"RT_resampledmods_langfelder-matchedLabels.RData"))
    write.csv(MEs,file=file.path(wd,"eigengenes.csv"))
    write.csv(kMEs, file=file.path(wd,"kMEs.csv"))
    write.csv(kIMs, file=file.path(wd,"kIMs.csv"))
    
    for (modcol in unique(mods1$colors)) {
        module.genes <- colnames(gev[,mods1$colors==modcol])
        write.table(module.genes, file=file.path(wd,paste("genes_",labels2colors(modcol),".txt",sep="")),
            quote=FALSE, row.names=FALSE, col.names=FALSE)
    }

}

```

## Plotting eigengenes by cell line (subtype)
Module eigengenes are stored in `mods1$MEs` with the cell lines in the order of the rownames of the original data in `gev` (gene expression values).

Plot the module eigengenes with the cell lines in order of their clusters.

```{r Eigengene heatmap}
modules <- data.frame(gene=colnames(gev),module=labels2colors(mods1$colors),modnum=mods1$colors,stringsAsFactors=FALSE)
# write.csv(modules, file=file.path(wd,"modules.csv"))

# heat map data
# hmd <- as.matrix(mods1$MEs[,colnames(mods1$MEs) != 'ME0'])
hmd <- as.matrix(mods1$MEs)

# colnames(hmd) <-
rownames(hmd) <- rownames(gev)
cl_cluster = phenotypes[order(phenotypes$X10_08_2020),'X10_08_2020']
cl_cluster.factor <- factor(cl_cluster)
hmd <- hmd[rownames(phenotypes[order(phenotypes$X10_08_2020),]),]
hmd <- hmd[,c('ME1',"ME3",'ME5', "ME9","ME2",'ME11',"ME8",'ME7','ME4',"ME6","ME10","ME12","ME13","ME14",'ME0')]
par(mar=c(4,2,.5,.5))

# heatmap.2(hmd,col=redblue(n=50), Rowv=FALSE, trace='none', dendrogram='none',
#         RowSideColors=standardColors()[cl_cluster[match(rownames(hmd),names(cl_cluster))]])
# legend('top',legend=c('nonNE','NEv1','Tuft','NEv2','NE'),fill=standardColors()[c(4,5,3,1,2)],border=0, cex=0.6)
pdf(file=file.path(wd,"WGCNA_heatmap_MEs_new.pdf"))

heatmap(hmd,col=bluered(n=50), Rowv=NA, Colv=NA,
      RowSideColors=c('green','blue','orange','turquoise','red','purple')[as.numeric(cl_cluster.factor)],
        cexRow=0.2,
  cexCol=0.8,)
legend('left',legend=unique(cl_cluster),
       fill=c('green','blue','orange','turquoise','red','purple'),
       border=0, cex=0.6)
dev.off()
```


### ME Enrichment by Subtype

According to the plot above:

A: enriched in ME1, ME3 (turquoise, brown)
A2:ME5 and ME9 (green, magenta)
N: ME1 and ME2, ME11 (H82) (turquoise, blue, greenyellow)
P: ME8 (pink)
Y: ME7 (black)

### GO terms enriched in modules
Let's look at what gene ontologies may be associated with each module. Must use EntrezID values when using the `WGCNA::GOenrichmentAnalysis` function. These can be found in a standard database at EBI. The file was downloaded from ftp://ftp.ebi.ac.uk/pub/databases/genenames/new/tsv/locus_types/gene_with_protein_product.txt and saved in `../data`. First, we will make a new function to obtain EntrezIDs from gene names in this file.
```{r EntrezIDs}

geneinfo <- read.csv('./data/gene_with_protein_product.txt',sep='\t',as.is=TRUE)
getEntrezID <- function(genename) geneinfo[match(genename,geneinfo$symbol),'entrez_id']
modules$entrez_id <- getEntrezID(modules$gene)

```

Next, let's try to identify GO terms enriched in each module. The original function in the `WGCNA` package is `GOenrichmentAnalysis`, which is still functional but considered deprecated. In addition to the all-encompassing GO group, there are groups corresponding to the GO ontologies Biological Process (BP), Cellular Component (CC) and Molecular Function (MF). 

```{r GO term enrichment}
GOenr <- GOenrichmentAnalysis(modules$module, modules$entrez_id, verbose=0)
```

Pull out the enriched terms and remove terms that do not pass a minimum P value (Bonferoni-corrected).
```{r}
mostenr <- GOenr$bestPTerms$BP$enrichment
mostenr_sig <- mostenr[mostenr$rank==1 | mostenr$BonferoniP <0.05,]
mostenr_sig[,c('module','rank','BonferoniP','termName')]
write.csv(mostenr_sig[,c('module','rank','BonferoniP','termName')], file = file.path(wd, 'Most_enriched_MC.csv'))
save(mostenr, file = file.path(wd,"Most_enriched_MC.Rdata"))

```